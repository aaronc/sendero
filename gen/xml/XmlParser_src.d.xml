<d:text>
class _{$parserName}(Ch = char)
{
        private static Logger log;

        private XmlCharIterator!(Ch)   text;
        private bool            err = false;
<d:block name="decls">
        Ch[]            prefix;    
        Ch[]            localName;     
        Ch[]            rawValue;
        int             depth = 0;
        XmlTokenType    type = XmlTokenType.None;
</d:block>
        static this()
        {
                log = Log.getLogger(&quot;sendero.xml.XmlParser!(&quot; ~ Ch.stringof ~ &quot;)&quot;);
        }
        
       /* static XmlParser!(Ch) opCall(Ch[] content)
        {
        	XmlParser!(Ch) itr;
            itr.reset (content);
            return itr;
        }*/
        
        this(Ch[] content)
        {
<d:block name="ctr">
        	reset(content);
</d:block>
        }
        
        private bool doAttributeName()
        {
            auto p = text.point;
            auto q = text.eatAttrName (p);

            if (*q == &apos;:&apos;)
            {
<d:block name="action_AttrNSName">
                prefix = p[0 .. q - p];
                q = text.eatAttrName (p = q + 1);
                localName = p[0 .. q - p];
</d:block>
            }
            else 
            {
<d:block name="action_AttrName">
				prefix = null;
                localName = p[0 .. q - p];
</d:block>
            }
<d:block name="action_AttrTokenType">
            type = XmlTokenType.Attribute;
</d:block>
            
            if (*q &lt;= 32) 
            {
            do {
	        	if (++q &gt;= text.end)                                      
	        		return doEndOfStream();
	        	} while (*q &lt;= 32);
        	}
            
			if (*q is &apos;=&apos;)
				doAttributeValue (q + 1);
			return true;
        }

        private bool doEndEmptyElement()
        {
            if(text[0..2] != &quot;/&gt;&quot;)
                return doUnexpected(&quot;/&gt;&quot;);
 <d:block name="action_EndEmptyElem">
            type = XmlTokenType.EndEmptyElement;
            localName = prefix = null;
</d:block>               
            text.point += 2;
            return true;
        }
        
        private bool doComment()
        {
            auto p = text.point;
            //type = XmlTokenType.Comment;
                
            while (text.good)
            {
                if (! text.forwardLocate(&apos;-&apos;)) 
                    return doUnexpectedEOF();

                if (text[0..3] == &quot;--&gt;&quot;) 
                {
<d:block name="action_Comment">
                    rawValue = p [0 .. text.point - p];
					type = XmlTokenType.Comment;
                    //prefix = null;
</d:block>
                    text.point += 3;
                    return true;
                }
                ++text.point;
            }
            return doUnexpectedEOF();
        }
        
        private bool doCData()
        {
            auto p = text.point;
            //type = XmlTokenType.CData;
                
            while (text.good)
            {
                if (! text.forwardLocate(&apos;]&apos;)) 
                    return doUnexpectedEOF();
                
                if (text[0..3] == &quot;]]&gt;&quot;) 
                {
<d:block name="action_CDATA">
					type = XmlTokenType.CData;
                    rawValue = p [0 .. text.point - p];
                    //prefix = null;
</d:block>
                    text.point += 3;                      
                    return true;
                }
                ++text.point;
            }
            return doUnexpectedEOF();
        }

        
        private bool doPI()
        {
            //type = XmlTokenType.PI;
            auto p = text.point;
            text.eatElemName;
            ++text.point;
            while (text.good)
            {
                if (! text.forwardLocate(&apos;\?&apos;)) 
                    return doUnexpectedEOF();

                if (text.point[1] == &apos;&gt;&apos;) 
                {
<d:block name="action_PI">
					type = XmlTokenType.PI;
                    rawValue = p [0 .. text.point - p];
</d:block>
                    text.point += 2;
                    return true;
                }
                ++text.point;
            }
            return doUnexpectedEOF();
        }
        
        private bool doDoctype()
        {
                text.eatSpace;
                auto p = text.point;
                //type = XmlTokenType.Doctype;
                                
                while (text.good) 
                      {
                      if (*text.point == &apos;&gt;&apos;) 
                         {
<d:block name="action_Doctype">
						 type = XmlTokenType.Doctype;
                         rawValue = p [0 .. text.point - p];
</d:block>
                         prefix = null;
                         ++text.point;
                         return true;
                         }
                      else 
                         if (*text.point == &apos;[&apos;) 
                            {
                            ++text.point;
                            text.forwardLocate(&apos;]&apos;);
                            ++text.point;
                            }
                         else 
                            ++text.point;
                      }

                if (! text.good)
                      return doUnexpectedEOF();
                return true;
        }
        
        private bool doUnexpected(char[] msg = null)
        {
                log.warn(&quot;Unexpected event &quot; ~ msg ~ &quot; &quot; ~ Integer.toUtf8(type));
                err = true;
                return false;
        }
        
        private bool doUnexpectedEOF()
        {
                log.warn(&quot;Unexpected EOF&quot;);
                err = true;
                return false;
        }
        
        private bool doEndOfStream()
        {
                return false;
        }
              
        private bool doMain()
        {
                auto p = text.point;
                if (*p != &apos;&lt;&apos;) 
                   {
                   auto e = text.end;
                   auto q = p;
                   do {
                      if (*++p == &apos;&lt;&apos;)
                         {
                         type = XmlTokenType.Data;
                         rawValue = q [0 .. p - q];
                         text.point = p;
                         return true;
                         }
                      } while (p &lt; e);
                   return doUnexpectedEOF();
                   }

                switch (p[1])
                       {
                       case &apos;/&apos;:
                            p += 2;
                            auto e = text.end;
                            auto q = p;
                            while (q &lt; e)
                                  {
                                  auto c = *q;
                                  if (c &gt; 63 || text.name[c])
                                      ++q;
                                  else
                                     break;
                                  }
                            text.point = q;

                            if (*q != &apos;:&apos;) 
                               {
                               prefix = null;
                               localName = p[0 .. q - p];
                               }
                            else 
                               {
                               prefix = p[0 .. q - p];
                               p = ++text.point;
                               q = text.eatAttrName;
                               localName = p[0 .. q - p];
                               }
                            type = XmlTokenType.EndElement;
                
                            while (*q &lt;= 32 &amp;&amp; q &lt;= text.end)
                                   ++q;

                            if (*q == &apos;&gt;&apos;)
                               {
                               text.point = q + 1;
                               --depth;
                               return true;
                               }
                            return doUnexpected(&quot;&gt;&quot;);

                       case &apos;!&apos;:
                            if (text[2..4] == &quot;--&quot;) 
                               {
                               text.point += 4;
                               return doComment();
                               }       
                            else 
                               if (text[2..9] == &quot;[CDATA[&quot;) 
                                  {
                                  text.point += 9;
                                  return doCData();
                                  }
                               else 
                                  if (text[2..9] == &quot;DOCTYPE&quot;) 
                                     {
                                     text.point += 9;
                                     return doDoctype();
                                     }
                            return doUnexpected(&quot;!&quot;);

                       case &apos;\?&apos;:
                            text.point += 2;
                            return doPI();

                       default:
                            auto q = ++p;
                            auto e = text.end;
                            while (q &lt; e)
                                  {
                                  auto c = *q;
                                  if (c &gt; 63 || text.name[c])
                                      ++q;
                                  else
                                     break;
                                  }
                            text.point = q;

                            if (*q != &apos;:&apos;) 
                               {
                               prefix = null;
                               localName = p [0 .. q - p];
                               }
                            else
                               {
                               prefix = p [0 .. q - p];
                               p = ++text.point;
                               q = text.eatAttrName;
                               localName = p [0 .. q - p];
                               }
                            type = XmlTokenType.StartElement;
                            return true;
                       }

               return false;
        }
        
        final bool next()
        {      
                auto p = text.point;
                if (*p &lt;= 32) 
                   {
                   do {
                      if (++p &gt;= text.end)                                      
                          return doEndOfStream();
                      } while (*p &lt;= 32);
                   text.point = p;
                   }
                
                if (type &gt;= XmlTokenType.EndElement) 
                    return doMain;

                // in element
                switch (*p)
                       {
                       case &apos;/&apos;:
                            return doEndEmptyElement();

                       case &apos;&gt;&apos;:
                            ++depth;
                            ++text.point;
                            return doMain();

                       default:
                            break;
                       }
                return doAttributeName();
        }
        
        private void doAttributeValue(Ch* q)
        {
            auto p = text.eatSpace (q);
            auto quote = *p++;
            switch (quote)
            {
    			case &apos;&quot;&apos;:
    			case &apos;\&apos;&apos;:
    				q = text.forwardLocate(p, quote);
    				rawValue = p[0 .. q - p];
    				text.point = q + 1; //Skip end quote
    			break;

    			default: 
    				doUnexpected(&quot;\&apos; or \&quot;&quot;);
        	}
        }
        
        final Ch[] value()
        {
        	if(type == XmlTokenType.Attribute || type == XmlTokenType.Data)
        		return decodeBuiltinEntities!(Ch)(rawValue);
        	return rawValue;
        }
        
        final Ch[] name()
        {
        	if(prefix.length)
        		return prefix ~ &quot;:&quot; ~ localName;
        	return localName;
        }
                
        final bool error()
        {
                return err;
        }

        final bool reset()
        {
                text.seek(0);
                reset_;
                return true;
        }
        
        final void reset(Ch[] newText)
        {
                text.reset (newText);
                reset_;                
        }
        
        private void reset_()
        {
                err = false;
<d:block name="reset_init">
                depth = 0;
                type = XmlTokenType.None;
</d:block>	
                
                static if(Ch.sizeof == 1)
                {
                    //Read UTF8 BOM
                    if(*text.point == 0xef)
                    {
                        if(text.point[1] == 0xbb)
                        {
                            if(text.point[2] == 0xbf)
                                text.point += 3;
                        }
                    }
                }
                
                //TODO enable optional declaration parsing
                text.eatSpace;
                if(*text.point == &apos;&lt;&apos;)
                {
                    if(text.point[1] == &apos;\?&apos;)
                    {
                        if(text[2..5] == &quot;xml&quot;)
                        {
                            text.point += 5;
                            text.forwardLocate(&apos;\?&apos;);
                            text.point += 2;
                        }
                    }
                }
        }
}
</d:text>