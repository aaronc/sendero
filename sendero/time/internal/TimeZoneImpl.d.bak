module sendero.time.internal.TimeZoneImpl;

import tango.time.Time;
import tango.time.Clock;
import tango.time.chrono.Gregorian;
import sendero.time.data.ZoneInfo;


/+struct TimeZoneImpl
{
	char[] id;
	char[] name;
	TimeSpan offset;
	TimeSpan dstOffset;
	char[] format;
	char[] dstFormat;
	
}+/

struct ZoneImpl
{
	char[] name;
	TimeSpan offset;
	int ruleIdx;
	char[] stdFormat;
	char[] dstFormat;

	Time toLocal(Time utc)
	{
		if(ruleIdx < 0)
			return utc + offset;

		return utc + rules[ruleIdx].calcOffset(utc, offset);
	}

	Time toUtc(Time local)
	{
		if(ruleIdx < 0)
			return local - offset;

		return local - rules[ruleIdx].calcOffset(local - offset, offset);
	}
}

struct OnRule
{
	//enum Type {Day, Last, First};
	//Type type;
	bool onLast;
	uint month;
	uint dow;
	uint day;
	//enum AtType {Local, Standard, UTC};
	TimeSpan at;
	//AtType atType;
	deprecated bool atUtc;
}

struct Rule
{
	char[] name;
	//OnRule first;
	//OnRule second;
	//TimeSpan offsetOne;
	//TimeSpan offsetTwo;
	OnRule[2] onRules;
	TimeSpan[2] offsets;
	bool atUtc;
	Time[] cache;

	TimeSpan calcOffset(Time utc, TimeSpan offset)
	{
		void etc()
		{
			uint yr, mon, day, doy, dow, era;
			Gregorian.generic.split(utc, yr, mon, day, doy, dow, era);

			if(mon > onRules[0].month && mon < onRules[1].month)
				return offsets[1] + offset;

			if(mon < onRules[0].month || mon > onRules[1].month)
				return offsets[0] + offset;
			
			if(mon == onRules[0].month) {
				Time dst;
				getDSTTimeForYear(yr, onRules[0], dst);
				if(utc < dst)
					return offsets[0] + offset;
				else
					return offsets[1] + offset;
			}
			else {
				Time dst;
				getDSTTimeForYear(yr, onRules[1], dst);
				if(utc < dst)
					return offsets[1] + offset;
				else
					return offsets[0] + offset;
			}			
		}

		if(!cache.length) updateCache;
		
		if(!atUtc) utc += offset;
		
		if(utc < cache[2]) {
			if(utc >= cache[1])
				return offsets[0] + offset;
			else if(utc >= cache[0])
				return offsets[1] + offset;
			else return etc;
		}
		else if(utc < cache[4]) {
			else if(utc >= cache[3])
				return offsets[0] + offset;
			else if(utc >= cache[2])
				return offsets[1] + offset;
		}
		else if(utc < cache[5])
			return offsets[0] + offset;
		else return etc;

		/+

		for(uint i = 1; i < 6; ++i)
		{
			if(utc < cache[i])
				return offsets[i & 1] + offset;
		}
		+/
		/+if(utc < cache[1])
			return offsets[0] + offset;

		if(utc < cache[2])
			return offsets[1] + offset;

		if(utc < cache[3])
			return offsets[0] + offset;

		if(utc < cache[4])
			return offsets[1] + offset;

		if(utc < cache[5])
			return offsets[0] + offset;
		+/

		
	/+	//auto mon = Gregorian.generic.getMonth(t);
		uint yr, mon, day, doy, dow, era;
		Gregorian.generic.split(utc, yr, mon, day, doy, dow, era);

		if(mon < first.month) {
			return offsetOne + offset;
		}
		else if(mon == first.month) {
			if(!first.onLast) {
				if(day < first.day)
					return offsetOne + offset;

				auto dist = day - first.day;
				auto dowdist = dow - first.dow;
				if(dowdist < 0) dowdist += 7;
				dowdist = dowdist % 7;

				if(dist > dowdist)
					return offsetTwo + offset;
				else if(dist < dowdist)
					return offsetOne + offset;
				else {
					//The actual day of the time change
				}

				//17 15
				//2
				//0
			}
			else {
			}
		}
		else if(mon <  second.month) {
			return offsetTwo;
		}
		else if(mon == second.month) {
			if(!first.onLast) {
				if(day < second.day)
					return offsetTwo + offset;
			}
			else {
			}
		}
		else {
			return offsetOne;
		}+/
		return TimeSpan(0);
	}

	void updateCache()
	{
		Time[] times = new Time[6];
		alias Gregorian.generic gg;
		auto yr = gg.getYear(Clock.now);
		--yr;
		getDSTTimeForYear(yr, onRules[0], times[0]);
		getDSTTimeForYear(yr, onRules[1], times[1]);

		++yr;
		getDSTTimeForYear(yr, onRules[0], times[2]);
		getDSTTimeForYear(yr, onRules[1], times[3]);

		++yr;
		getDSTTimeForYear(yr, onRules[0], times[4]);
		getDSTTimeForYear(yr, onRules[1], times[5]);
		
		cache = times;
		
	}

	static void getDSTTimeForYear(uint yr, OnRule onrule, ref Time onTime)
	{
		alias Gregorian.generic gg;
		if(!onrule.onLast) {
			onTime = gg.toTime(yr, onrule.month, onrule.day, 0, 0, 0, 0, 1);
			auto dow = gg.getDayOfWeek(onTime);
			auto day = onrule.dow - dow;
			if(day < 0) day += 7;
			day += onrule.day;
			onTime = gg.toTime(yr, onrule.month, day, 0, 0, 0, 0, 1);
			
		}
		else {
			auto dim = gg.getDaysInMonth(yr, onrule.month, 1);
			onTime = gg.toTime(yr, onrule.month, dim, 0, 0, 0, 0, 1);
			auto dow = gg.getDayOfWeek(onTime);
			auto day = onrule.dow - dow;
			if(day > 0) day -= 7;
			day += onrule.day;
			onTime = gg.toTime(yr, onrule.month, day, 0, 0, 0, 0, 1);
		}
		onTime += onrule.at;
	}

	/+DateTime toLocalDT(Time utc, TimeSpan offset)
	{
		//auto mon = Gregorian.generic.getMonth(t);
		uint yr, mon, day, doy, dow, era;
		Gregorian.split(utc, yr, day, doy, dow, era);

		if(mon < first.month) {
			return offsetOne;
		}
		else if(mon == first.month) {
			if(!first.onLast) {
				
			}
		}
		else if(mon <  second.month) {
			return offsetTwo;
		}
		else if(mon == second.month) {
		}
		else {
			return offsetOne;
		}
	}+/
}

version(Unittest)
{
unittest
{
	/+int test(uint day, uint targetday, uint dow, uint targetdow)
	{
		auto dist = day - targetday;
		if	

		auto dowdist = dow - targetdow;
		if(dowdist < 0) dowdist += 7;

		if(dist  7) {
			if
		}
	
		if(dist > dowdist)
			return 1;
		else if(dist < dowdist)
			return -1;
		else {
			return 0;
		}
	}+/

	assert(test(19, 15, 2, 0) == 1);
	assert(test(19, 15, 6, 0) == -1);
	assert(test(19, 15, 0, 0) == 0);
}
}