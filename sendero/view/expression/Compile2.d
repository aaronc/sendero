// Written in the D programming language

/*
 *  This file has been automatically generated by APaGeD v0.4.2 beta - Attributed Parser Generator for D.
 *
 *  Sections generated from custom input are marked as "generated code" and
 *  are subject to the terms and conditions stated in one of these sections.
 *  The remaining sections are part of the APaGeD package and subject
 *  to the terms and conditions of the corresponding license.
 *
 *  Attributed Parser Generator for D
 *  Copyright (c) 2007 Jascha Wetzel. All rights reserved
 *  License: Artistic License 2.0
 */

// generated code start

#line 2 "Compile2.apd"

	module sendero.view.expression.Compile2;
	
	import tango.io.Stdout;
	import tango.text.convert.Integer;
	import Float = tango.text.convert.Float;

version(TestApaged)
{
/+	import sendero.util.LocalText;

    void main(string[] args)
    {
        if ( args.length &lt; 2 )
            throw new Exception("Usage: arithmetic &lt;expression>");
        SyntaxTree* root;
        if ( parse("", args[1], root, true) ) {
            Expression value;
            root.Expr(value);
            debug root.print;
			auto ctxt = new ExecutionContext;
			auto res = value.exec(ctxt);
			auto text = Message.renderParam(ctxt, res);
            Stdout.format("{} = {}\n", args[1], text);
        }
        else
        {
            Stdout.format("Invalid expression: {}\n", args[1]);
        }
    }+/
}
// generated code end

version(Tango)
{
  
}
else
{
    import std.string;
    debug import std.stdio;
}

/**************************************************************************************************
    Semantic Analyzer
**************************************************************************************************/

class SemanticException : Exception
{
    this(string msg)
    {
        super(msg);
    }
}

struct SyntaxTree
{
    uint            _ST_rule,
                    _ST_line_number,
                    _ST_column_number;
    debug
    {
        string          _ST_node_name,
                        _ST_match,
                        _ST_match_ws;
        SyntaxTree*[]   _ST_children;
    }
    else
    {
        union
        {
            struct {
                string      _ST_match,
                            _ST_match_ws;
            }
            SyntaxTree*[]   _ST_children;
        }
    }

    debug
    {
        SyntaxTree* parent;

        string indent()
        {
            string str;
            for ( SyntaxTree* n = parent; n !is null; n = n.parent )
                str ~= "  ";
            return str;
        }

        void print(string indent = "")
        {
            version(Tango)
                Stdout.format("{}{}{}", indent, _ST_node_name, _ST_rule);
            else
                writef("%s%s%d", indent, _ST_node_name, _ST_rule);
            if ( _ST_children.length == 0 )
            {
                version(Tango)
                    Stdout.formatln(" (\"{}\")", _ST_match);
                else
                    writefln(" (\"%s\")", _ST_match);
            }
            else
            {
                version(Tango)
                    Stdout.newline;
                else
                    writefln;
            }
            foreach ( c; _ST_children )
                c.print(indent~"  ");
        }
    }

    void opCatAssign(SyntaxTree* n)
    {
        _ST_children ~= n;
    }

    // augmented semantic code
// generated code start
    alias _S_Expr Expr;
void _S_Expr(inout Expression expr)
{

    switch ( _ST_rule )
    {
    case 0:
        debug assert(_ST_children.length == 1);
        void delegate(inout Expression value) OrExpr = &_ST_children[0]._S_OrExpr;

#line 44 "Compile2.apd"

		OrExpr(expr);
        break;

    default:
        assert(0);
    }
}
void _S_OrExpr(inout Expression value)
{

    switch ( _ST_rule )
    {
    case 1:
        debug assert(_ST_children.length == 1);
        void delegate(inout Expression value) AndExpr = &_ST_children[0]._S_AndExpr;

#line 53 "Compile2.apd"

		AndExpr(value);
        break;
    case 2:
        debug assert(_ST_children.length == 2);
        void delegate(inout Expression value) OrExpr = &_ST_children[0]._S_OrExpr;
        void delegate(inout Expression value) AndExpr = &_ST_children[1]._S_AndExpr;

#line 58 "Compile2.apd"

		Expression x, y;
        break;

    default:
        assert(0);
    }
}
void _S_AndExpr(inout Expression value)
{

    switch ( _ST_rule )
    {
    case 3:
        debug assert(_ST_children.length == 1);
        void delegate(inout Expression value) EqualityExpr = &_ST_children[0]._S_EqualityExpr;

#line 66 "Compile2.apd"

		EqualityExpr(value);
        break;
    case 4:
        debug assert(_ST_children.length == 2);
        void delegate(inout Expression value) AndExpr = &_ST_children[0]._S_AndExpr;
        void delegate(inout Expression value) EqualityExpr = &_ST_children[1]._S_EqualityExpr;

#line 71 "Compile2.apd"

		Expression x, y;
		AndExpr(x);
		EqualityExpr(y);
        break;

    default:
        assert(0);
    }
}
void _S_EqualityExpr(inout Expression value)
{

    switch ( _ST_rule )
    {
    case 5:
        debug assert(_ST_children.length == 1);
        void delegate(inout Expression value) RelationalExpr = &_ST_children[0]._S_RelationalExpr;

#line 81 "Compile2.apd"

		RelationalExpr(value);
        break;
    case 6:
        debug assert(_ST_children.length == 2);
        void delegate(inout Expression value) EqualityExpr = &_ST_children[0]._S_EqualityExpr;
        void delegate(inout Expression value) RelationalExpr = &_ST_children[1]._S_RelationalExpr;

#line 86 "Compile2.apd"

		Expression x, y;
		EqualityExpr(x);
		RelationalExpr(y);
        break;
    case 7:
        debug assert(_ST_children.length == 2);
        void delegate(inout Expression value) EqualityExpr = &_ST_children[0]._S_EqualityExpr;
        void delegate(inout Expression value) RelationalExpr = &_ST_children[1]._S_RelationalExpr;

#line 93 "Compile2.apd"

		Expression x, y;
		EqualityExpr(x);
		RelationalExpr(y);
        break;

    default:
        assert(0);
    }
}
void _S_RelationalExpr(inout Expression value)
{

    switch ( _ST_rule )
    {
    case 8:
        debug assert(_ST_children.length == 1);
        void delegate(inout Expression value) AdditiveExpr = &_ST_children[0]._S_AdditiveExpr;

#line 103 "Compile2.apd"

		AdditiveExpr(value);
        break;
    case 9:
        debug assert(_ST_children.length == 2);
        void delegate(inout Expression value) RelationalExpr = &_ST_children[0]._S_RelationalExpr;
        void delegate(inout Expression value) AdditiveExpr = &_ST_children[1]._S_AdditiveExpr;

#line 108 "Compile2.apd"

		Expression x, y;
		RelationalExpr(x);
		AdditiveExpr(y);
        break;
    case 10:
        debug assert(_ST_children.length == 2);
        void delegate(inout Expression value) RelationalExpr = &_ST_children[0]._S_RelationalExpr;
        void delegate(inout Expression value) AdditiveExpr = &_ST_children[1]._S_AdditiveExpr;

#line 115 "Compile2.apd"

		Expression x, y;
		RelationalExpr(x);
		AdditiveExpr(y);
        break;
    case 11:
        debug assert(_ST_children.length == 2);
        void delegate(inout Expression value) RelationalExpr = &_ST_children[0]._S_RelationalExpr;
        void delegate(inout Expression value) AdditiveExpr = &_ST_children[1]._S_AdditiveExpr;

#line 122 "Compile2.apd"

		Expression x, y;
		RelationalExpr(x);
		AdditiveExpr(y);
        break;
    case 12:
        debug assert(_ST_children.length == 2);
        void delegate(inout Expression value) RelationalExpr = &_ST_children[0]._S_RelationalExpr;
        void delegate(inout Expression value) AdditiveExpr = &_ST_children[1]._S_AdditiveExpr;

#line 129 "Compile2.apd"

		Expression x, y;
		RelationalExpr(x);
		AdditiveExpr(y);
        break;

    default:
        assert(0);
    }
}
void _S_AdditiveExpr(inout Expression value)
{

    switch ( _ST_rule )
    {
    case 13:
        debug assert(_ST_children.length == 2);
        void delegate(inout Expression value) AdditiveExpr = &_ST_children[0]._S_AdditiveExpr;
        void delegate(inout Expression value) MulExpr = &_ST_children[1]._S_MulExpr;

#line 139 "Compile2.apd"

		Expression x, y;
        AdditiveExpr(x);
        MulExpr(y);
        break;
    case 14:
        debug assert(_ST_children.length == 2);
        void delegate(inout Expression value) AdditiveExpr = &_ST_children[0]._S_AdditiveExpr;
        void delegate(inout Expression value) MulExpr = &_ST_children[1]._S_MulExpr;

#line 146 "Compile2.apd"

        Expression x, y;
        AdditiveExpr(x);
        MulExpr(y);
        break;
    case 15:
        debug assert(_ST_children.length == 1);
        void delegate(inout Expression value) MulExpr = &_ST_children[0]._S_MulExpr;

#line 153 "Compile2.apd"
 MulExpr(value);
        break;

    default:
        assert(0);
    }
}
void _S_MulExpr(inout Expression value)
{

    switch ( _ST_rule )
    {
    case 16:
        debug assert(_ST_children.length == 2);
        void delegate(inout Expression value) MulExpr = &_ST_children[0]._S_MulExpr;
        void delegate(inout Expression value) UnaryExpr = &_ST_children[1]._S_UnaryExpr;

#line 159 "Compile2.apd"

        Expression x, y;
        UnaryExpr(x);
        MulExpr(y);
        value.type = ExpressionT.Binary;
		value.binaryExpr.type = BinaryExpressionT.Mul;
		value.binaryExpr.expr ~= x;
		value.binaryExpr.expr ~= y;
        break;
    case 17:
        debug assert(_ST_children.length == 2);
        void delegate(inout Expression value) MulExpr = &_ST_children[0]._S_MulExpr;
        void delegate(inout Expression value) UnaryExpr = &_ST_children[1]._S_UnaryExpr;

#line 170 "Compile2.apd"

        Expression x, y;
        UnaryExpr(x);
        MulExpr(y);
        break;
    case 18:
        debug assert(_ST_children.length == 2);
        void delegate(inout Expression value) MulExpr = &_ST_children[0]._S_MulExpr;
        void delegate(inout Expression value) UnaryExpr = &_ST_children[1]._S_UnaryExpr;

#line 177 "Compile2.apd"

        Expression x, y;
        UnaryExpr(x);
        MulExpr(y);
        break;
    case 19:
        debug assert(_ST_children.length == 1);
        void delegate(inout Expression value) UnaryExpr = &_ST_children[0]._S_UnaryExpr;

#line 184 "Compile2.apd"
 UnaryExpr(value);
        break;

    default:
        assert(0);
    }
}
void _S_UnaryExpr(inout Expression value)
{

    switch ( _ST_rule )
    {
    case 20:
        debug assert(_ST_children.length == 1);
        void delegate(inout Expression value) UnaryExpr = &_ST_children[0]._S_UnaryExpr;

#line 191 "Compile2.apd"

		Expression val;
        UnaryExpr(val);
        break;
    case 21:
        debug assert(_ST_children.length == 1);
        void delegate(inout Expression value) PrimaryExpr = &_ST_children[0]._S_PrimaryExpr;

#line 197 "Compile2.apd"
 PrimaryExpr(value);
        break;

    default:
        assert(0);
    }
}
void _S_Literal(char[] value)
{

    switch ( _ST_rule )
    {
    case 22:
        debug assert(_ST_children.length == 0);

#line 205 "Compile2.apd"

		value = _ST_match[1 .. $-1];
        break;
    case 23:
        debug assert(_ST_children.length == 0);

#line 211 "Compile2.apd"

		value = _ST_match[1 .. $-1];
        break;

    default:
        assert(0);
    }
}
void _S_PrimaryExpr(inout Expression value)
{

    switch ( _ST_rule )
    {
    case 24:
        debug assert(_ST_children.length == 0);

#line 219 "Compile2.apd"

		long val = atoi(_ST_match);
        break;
    case 25:
        debug assert(_ST_children.length == 0);

#line 224 "Compile2.apd"

		double val = Float.parse(_ST_match);
        break;
    case 26:
        debug assert(_ST_children.length == 1);
        void delegate(char[] value) Literal = &_ST_children[0]._S_Literal;

#line 229 "Compile2.apd"

		char[] val;
		Literal(val);
        break;
    case 27:
        debug assert(_ST_children.length == 1);
        void delegate(inout Expression expr) FuncCall = &_ST_children[0]._S_FuncCall;

#line 235 "Compile2.apd"

		FuncCall(value);
        break;
    case 28:
        debug assert(_ST_children.length == 1);
        void delegate() VarRef = &_ST_children[0]._S_VarRef;

#line 240 "Compile2.apd"

		VarRef(value);
        break;
    case 29:
        debug assert(_ST_children.length == 1);
        void delegate(inout Expression expr) Expr = &_ST_children[0]._S_Expr;

#line 245 "Compile2.apd"
 Expr(value);
        break;

    default:
        assert(0);
    }
}
void _S_FuncCall(inout Expression expr)
{

    switch ( _ST_rule )
    {
    case 30:
        debug assert(_ST_children.length == 2);
        void delegate() VarRef = &_ST_children[0]._S_VarRef;
        void delegate(inout Expression[] args) ExprList = &_ST_children[1]._S_ExprList;

#line 251 "Compile2.apd"

		expr.type = ExpressionT.FuncCall;
		ExprList(expr.func.params);
        break;

    default:
        assert(0);
    }
}
void _S_ExprList(inout Expression[] args)
{

    switch ( _ST_rule )
    {
    case 31:
        debug assert(_ST_children.length == 2);
        void delegate(inout Expression expr) Expr = &_ST_children[0]._S_Expr;
        void delegate(inout Expression[] args) ExprList = &_ST_children[1]._S_ExprList;

#line 260 "Compile2.apd"

		Expression expr;
		Expression exprList[];
		Expr(expr);
		ExprList(exprList);
		args ~= expr;
		args ~= exprList;
        break;
    case 32:
        debug assert(_ST_children.length == 1);
        void delegate(inout Expression expr) Expr = &_ST_children[0]._S_Expr;

#line 270 "Compile2.apd"

		Expression expr;
		args ~= expr;
        break;
    case 33:
        debug assert(_ST_children.length == 0);
        break;

    default:
        assert(0);
    }
}
void _S_VarRef()
{

    switch ( _ST_rule )
    {
    case 34:
        debug assert(_ST_children.length == 2);
        break;
    case 35:
        debug assert(_ST_children.length == 2);
        break;
    case 36:
        debug assert(_ST_children.length == 1);
        break;

    default:
        assert(0);
    }
}
void _S_Identifier()
{

    switch ( _ST_rule )
    {
    case 37:
        debug assert(_ST_children.length == 0);
        break;

    default:
        assert(0);
    }
}

// generated code end
}

#line 611 "Compile2.d"
// Written in the D programming language

/*
 *  This file has been automatically generated by APaGeD v0.4.2 beta - Attributed Parser Generator for D.
 *
 *  Sections generated from custom input are marked as "generated code" and
 *  are subject to the terms and conditions stated in one of these sections.
 *  The remaining sections are part of the APaGeD package and subject
 *  to the terms and conditions of the corresponding license.
 *
 *  Attributed Parser Generator for D
 *  Copyright (c) 2007 Jascha Wetzel. All rights reserved
 *  License: Artistic License 2.0
 */

/**************************************************************************************************
    Lexer
**************************************************************************************************/

version(Tango)
// the following block is stolen from phobos.
// the copyright notice applies for this block only.
{
/*
 *  Copyright (C) 2003-2004 by Digital Mars, www.digitalmars.com
 *  Written by Walter Bright
 *
 *  This software is provided 'as-is', without any express or implied
 *  warranty. In no event will the authors be held liable for any damages
 *  arising from the use of this software.
 *
 *  Permission is granted to anyone to use this software for any purpose,
 *  including commercial applications, and to alter it and redistribute it
 *  freely, subject to the following restrictions:
 *
 *  o  The origin of this software must not be misrepresented; you must not
 *     claim that you wrote the original software. If you use this software
 *     in a product, an acknowledgment in the product documentation would be
 *     appreciated but is not required.
 *  o  Altered source versions must be plainly marked as such, and must not
 *     be misrepresented as being the original software.
 *  o  This notice may not be removed or altered from any source
 *     distribution.
 */

bool isValidDchar(dchar c)
{
    /* Note: FFFE and FFFF are specifically permitted by the
     * Unicode standard for application internal use, but are not
     * allowed for interchange.
     * (thanks to Arcane Jill)
     */

    return c < 0xD800 ||
	(c > 0xDFFF && c <= 0x10FFFF /*&& c != 0xFFFE && c != 0xFFFF*/);
}

/***************
 * Decodes and returns character starting at s[idx]. idx is advanced past the
 * decoded character. If the character is not well formed, a UtfException is
 * thrown and idx remains unchanged.
 */

dchar decode(in char[] s, inout size_t idx)
    {
	size_t len = s.length;
	dchar V;
	size_t i = idx;
	char u = s[i];

	if (u & 0x80)
	{   uint n;
	    char u2;

	    /* The following encodings are valid, except for the 5 and 6 byte
	     * combinations:
	     *	0xxxxxxx
	     *	110xxxxx 10xxxxxx
	     *	1110xxxx 10xxxxxx 10xxxxxx
	     *	11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
	     *	111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
	     *	1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
	     */
	    for (n = 1; ; n++)
	    {
		if (n > 4)
		    goto Lerr;		// only do the first 4 of 6 encodings
		if (((u << n) & 0x80) == 0)
		{
		    if (n == 1)
			goto Lerr;
		    break;
		}
	    }

	    // Pick off (7 - n) significant bits of B from first byte of octet
	    V = cast(dchar)(u & ((1 << (7 - n)) - 1));

	    if (i + (n - 1) >= len)
		goto Lerr;			// off end of string

	    /* The following combinations are overlong, and illegal:
	     *	1100000x (10xxxxxx)
	     *	11100000 100xxxxx (10xxxxxx)
	     *	11110000 1000xxxx (10xxxxxx 10xxxxxx)
	     *	11111000 10000xxx (10xxxxxx 10xxxxxx 10xxxxxx)
	     *	11111100 100000xx (10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx)
	     */
	    u2 = s[i + 1];
	    if ((u & 0xFE) == 0xC0 ||
		(u == 0xE0 && (u2 & 0xE0) == 0x80) ||
		(u == 0xF0 && (u2 & 0xF0) == 0x80) ||
		(u == 0xF8 && (u2 & 0xF8) == 0x80) ||
		(u == 0xFC && (u2 & 0xFC) == 0x80))
		goto Lerr;			// overlong combination

	    for (uint j = 1; j != n; j++)
	    {
		u = s[i + j];
		if ((u & 0xC0) != 0x80)
		    goto Lerr;			// trailing bytes are 10xxxxxx
		V = (V << 6) | (u & 0x3F);
	    }
	    if (!isValidDchar(V))
		goto Lerr;
	    i += n;
	}
	else
	{
	    V = cast(dchar) u;
	    i++;
	}

	idx = i;
	return V;

      Lerr:
	throw new Exception("4invalid UTF-8 sequence");
    }
}
else
{
    import std.utf;
}

// lexer code
// generated code start
// ((?\|\|)|(?&&)|(?==)|(?!=)|(?\<)|(?\>)|(?\<=)|(?\>=)|(?\+)|(?\-)|(?\*)|(?div)|(?mod)|(?"[^"]*")|(?'[^']*')|(?[0-9]+)|(?[0-9]+\.[0-9]+)|(?\()|(?\))|(?,)|(?\.)|(?\[)|(?\])|(?[A-Za-z_][A-Za-z_0-9]*)).*?
bool mainLexer(string input, out uint token, out string match)
{
    uint s = 0;
    static int r48=-1, r49=-1, r50=-1, r51=-1, r52=-1, r53=-1, r54=-1, r55=-1, r56=-1, r57=-1, 
        r58=-1, r59=-1, r60=-1, r61=-1, r62=-1, r63=-1, r64=-1, r65=-1, r66=-1, r67=-1, 
        r68=-1, r69=-1, r70=-1, r71=-1, r72=-1, r73=-1, r74=-1, r75=-1;

    for ( size_t p = 0, q = 0, p_end = input.length; p < p_end; q = p )
    {
        dchar c = cast(dchar)input[p];
        if ( c & 0x80 )
            decode(input, p);
        else
            ++p;
        switch ( s )
        {
            case 0:
                if ( c == 0x3c ) {
                    s = 17;
                    r58 = p;
                }
                else if ( c == 0x26 ) {
                    s = 2;
                }
                else if ( c == 0x5b ) {
                    s = 14;
                    r55 = p;
                }
                else if ( c == 0x5d ) {
                    s = 15;
                    r56 = p;
                }
                else if ( c == 0x3e ) {
                    s = 18;
                    r59 = p;
                }
                else if ( c == 0x2c ) {
                    s = 12;
                    r53 = p;
                }
                else if ( c == 0x64 ) {
                    s = 19;
                    r57 = p;
                }
                else if ( c == 0x6d ) {
                    s = 20;
                    r57 = p;
                }
                else if ( c == 0x2e ) {
                    s = 13;
                    r54 = p;
                }
                else if ( c == 0x29 ) {
                    s = 11;
                    r52 = p;
                }
                else if ( c == 0x7c ) {
                    s = 1;
                }
                else if ( c == 0x2b ) {
                    s = 5;
                    r48 = p;
                }
                else if ( c == 0x27 ) {
                    s = 9;
                }
                else if ( c == 0x3d ) {
                    s = 3;
                }
                else if ( c == 0x21 ) {
                    s = 4;
                }
                else if ( c == 0x2d ) {
                    s = 6;
                    r49 = p;
                }
                else if ( c == 0x28 ) {
                    s = 10;
                    r51 = p;
                }
                else if ( c == 0x2a ) {
                    s = 7;
                    r50 = p;
                }
                else if ( c == 0x22 ) {
                    s = 8;
                }
                else if ( c >= 0x30 && c <= 0x39 ) {
                    s = 21;
                    r60 = p;
                }
                else if ( c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x63 || c >= 0x65 && c <= 0x6c || c >= 0x6e && c <= 0x7a ) {
                    s = 16;
                    r57 = p;
                }
                else
                    return false;
                break;
            case 1:
                if ( c == 0x7c ) {
                    s = 65;
                    r61 = p;
                }
                else
                    return false;
                break;
            case 2:
                if ( c == 0x26 ) {
                    s = 63;
                    r62 = p;
                }
                else
                    return false;
                break;
            case 3:
                if ( c == 0x3d ) {
                    s = 61;
                    r63 = p;
                }
                else
                    return false;
                break;
            case 4:
                if ( c == 0x3d ) {
                    s = 59;
                    r64 = p;
                }
                else
                    return false;
                break;
            case 5:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 58;
                }
                else
                    goto finish5;
                break;
            case 6:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 57;
                }
                else
                    goto finish6;
                break;
            case 7:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 56;
                }
                else
                    goto finish7;
                break;
            case 8:
                if ( c == 0x22 ) {
                    s = 54;
                    r65 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 53;
                }
                else
                    return false;
                break;
            case 9:
                if ( c == 0x27 ) {
                    s = 51;
                    r66 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 50;
                }
                else
                    return false;
                break;
            case 10:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 49;
                }
                else
                    goto finish10;
                break;
            case 11:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 48;
                }
                else
                    goto finish11;
                break;
            case 12:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 47;
                }
                else
                    goto finish12;
                break;
            case 13:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 46;
                }
                else
                    goto finish13;
                break;
            case 14:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 45;
                }
                else
                    goto finish14;
                break;
            case 15:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 44;
                }
                else
                    goto finish15;
                break;
            case 16:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 28;
                    r67 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 30;
                }
                else
                    goto finish16;
                break;
            case 17:
                if ( c == 0x3d ) {
                    s = 42;
                    r68 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 41;
                }
                else
                    goto finish17;
                break;
            case 18:
                if ( c == 0x3d ) {
                    s = 39;
                    r69 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 38;
                }
                else
                    goto finish18;
                break;
            case 19:
                if ( c == 0x69 ) {
                    s = 34;
                    r67 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 28;
                    r67 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 30;
                }
                else
                    goto finish19;
                break;
            case 20:
                if ( c == 0x6f ) {
                    s = 29;
                    r67 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 28;
                    r67 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 30;
                }
                else
                    goto finish20;
                break;
            case 21:
                if ( c == 0x2e ) {
                    s = 22;
                }
                else if ( c >= 0x30 && c <= 0x39 ) {
                    s = 23;
                    r70 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                }
                else
                    goto finish21;
                break;
            case 22:
                if ( c >= 0x30 && c <= 0x39 ) {
                    s = 25;
                    r71 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                }
                else
                    goto finish22;
                break;
            case 23:
                if ( c == 0x2e ) {
                    s = 22;
                    r60 = r70;
                }
                else if ( c >= 0x30 && c <= 0x39 ) {
                    s = 23;
                    r60 = r70;
                    r70 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r60 = r70;
                }
                else
                    goto finish23;
                break;
            case 24:
                goto finish24;
            case 25:
                if ( c >= 0x30 && c <= 0x39 ) {
                    s = 27;
                    r72 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 26;
                }
                else
                    goto finish25;
                break;
            case 26:
                goto finish26;
            case 27:
                if ( c >= 0x30 && c <= 0x39 ) {
                    s = 27;
                    r71 = r72;
                    r72 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 26;
                    r71 = r72;
                }
                else
                    goto finish27;
                break;
            case 28:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 28;
                    r57 = r67;
                    r67 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 30;
                    r57 = r67;
                }
                else
                    goto finish28;
                break;
            case 29:
                if ( c == 0x64 ) {
                    s = 31;
                    r73 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 28;
                    r57 = r67;
                    r67 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 30;
                    r57 = r67;
                }
                else
                    goto finish29;
                break;
            case 30:
                goto finish30;
            case 31:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 33;
                    r74 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 32;
                }
                else
                    goto finish31;
                break;
            case 32:
                goto finish32;
            case 33:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 28;
                    r57 = r74;
                    r67 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 30;
                    r57 = r74;
                }
                else
                    goto finish33;
                break;
            case 34:
                if ( c == 0x76 ) {
                    s = 35;
                    r75 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 28;
                    r57 = r67;
                    r67 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 30;
                    r57 = r67;
                }
                else
                    goto finish34;
                break;
            case 35:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 37;
                    r74 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 36;
                }
                else
                    goto finish35;
                break;
            case 36:
                goto finish36;
            case 37:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 28;
                    r57 = r74;
                    r67 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 30;
                    r57 = r74;
                }
                else
                    goto finish37;
                break;
            case 38:
                goto finish38;
            case 39:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 40;
                }
                else
                    goto finish39;
                break;
            case 40:
                goto finish40;
            case 41:
                goto finish41;
            case 42:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 43;
                }
                else
                    goto finish42;
                break;
            case 43:
                goto finish43;
            case 44:
                goto finish44;
            case 45:
                goto finish45;
            case 46:
                goto finish46;
            case 47:
                goto finish47;
            case 48:
                goto finish48;
            case 49:
                goto finish49;
            case 50:
                if ( c == 0x27 ) {
                    s = 51;
                    r66 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 50;
                }
                else
                    return false;
                break;
            case 51:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 52;
                }
                else
                    goto finish51;
                break;
            case 52:
                goto finish52;
            case 53:
                if ( c == 0x22 ) {
                    s = 54;
                    r65 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 53;
                }
                else
                    return false;
                break;
            case 54:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 55;
                }
                else
                    goto finish54;
                break;
            case 55:
                goto finish55;
            case 56:
                goto finish56;
            case 57:
                goto finish57;
            case 58:
                goto finish58;
            case 59:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 60;
                }
                else
                    goto finish59;
                break;
            case 60:
                goto finish60;
            case 61:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 62;
                }
                else
                    goto finish61;
                break;
            case 62:
                goto finish62;
            case 63:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 64;
                }
                else
                    goto finish63;
                break;
            case 64:
                goto finish64;
            case 65:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 66;
                }
                else
                    goto finish65;
                break;
            case 66:
                goto finish66;
            default:
                assert(0);
        }
    }

    switch ( s )
    {
        case 5: finish5:
        case 58: finish58:
            match = input[0 .. r48];
            token = 8;
            break;
        case 6: finish6:
        case 57: finish57:
            match = input[0 .. r49];
            token = 9;
            break;
        case 7: finish7:
        case 56: finish56:
            match = input[0 .. r50];
            token = 10;
            break;
        case 10: finish10:
        case 49: finish49:
            match = input[0 .. r51];
            token = 17;
            break;
        case 11: finish11:
        case 48: finish48:
            match = input[0 .. r52];
            token = 18;
            break;
        case 12: finish12:
        case 47: finish47:
            match = input[0 .. r53];
            token = 19;
            break;
        case 13: finish13:
        case 46: finish46:
            match = input[0 .. r54];
            token = 20;
            break;
        case 14: finish14:
        case 45: finish45:
            match = input[0 .. r55];
            token = 21;
            break;
        case 15: finish15:
        case 44: finish44:
            match = input[0 .. r56];
            token = 22;
            break;
        case 16: finish16:
        case 19: finish19:
        case 20: finish20:
        case 30: finish30:
            match = input[0 .. r57];
            token = 23;
            break;
        case 17: finish17:
        case 41: finish41:
            match = input[0 .. r58];
            token = 4;
            break;
        case 18: finish18:
        case 38: finish38:
            match = input[0 .. r59];
            token = 5;
            break;
        case 21: finish21:
        case 22: finish22:
        case 24: finish24:
            match = input[0 .. r60];
            token = 15;
            break;
        case 23: finish23:
            match = input[0 .. r70];
            token = 15;
            break;
        case 25: finish25:
        case 26: finish26:
            match = input[0 .. r71];
            token = 16;
            break;
        case 27: finish27:
            match = input[0 .. r72];
            token = 16;
            break;
        case 28: finish28:
        case 29: finish29:
        case 34: finish34:
            match = input[0 .. r67];
            token = 23;
            break;
        case 31: finish31:
        case 32: finish32:
            match = input[0 .. r73];
            token = 12;
            break;
        case 33: finish33:
        case 37: finish37:
            match = input[0 .. r74];
            token = 23;
            break;
        case 35: finish35:
        case 36: finish36:
            match = input[0 .. r75];
            token = 11;
            break;
        case 39: finish39:
        case 40: finish40:
            match = input[0 .. r69];
            token = 7;
            break;
        case 42: finish42:
        case 43: finish43:
            match = input[0 .. r68];
            token = 6;
            break;
        case 51: finish51:
        case 52: finish52:
            match = input[0 .. r66];
            token = 14;
            break;
        case 54: finish54:
        case 55: finish55:
            match = input[0 .. r65];
            token = 13;
            break;
        case 59: finish59:
        case 60: finish60:
            match = input[0 .. r64];
            token = 3;
            break;
        case 61: finish61:
        case 62: finish62:
            match = input[0 .. r63];
            token = 2;
            break;
        case 63: finish63:
        case 64: finish64:
            match = input[0 .. r62];
            token = 1;
            break;
        case 65: finish65:
        case 66: finish66:
            match = input[0 .. r61];
            token = 0;
            break;
        default:
            return false;
    }
    return true;
}
// ((?[ \t\n\r]+)).*?
bool wsLexer(string input, out uint token, out string match)
{
    uint s = 0;
    static int r2=-1, r3=-1;

    for ( size_t p = 0, q = 0, p_end = input.length; p < p_end; q = p )
    {
        dchar c = cast(dchar)input[p];
        if ( c & 0x80 )
            decode(input, p);
        else
            ++p;
        switch ( s )
        {
            case 0:
                if ( c >= 0x9 && c <= 0xa || c == 0xd || c == 0x20 ) {
                    s = 1;
                    r2 = p;
                }
                else
                    return false;
                break;
            case 1:
                if ( c >= 0x9 && c <= 0xa || c == 0xd || c == 0x20 ) {
                    s = 3;
                    r3 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 2;
                }
                else
                    goto finish1;
                break;
            case 2:
                goto finish2;
            case 3:
                if ( c >= 0x9 && c <= 0xa || c == 0xd || c == 0x20 ) {
                    s = 3;
                    r2 = r3;
                    r3 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 2;
                    r2 = r3;
                }
                else
                    goto finish3;
                break;
            default:
                assert(0);
        }
    }

    switch ( s )
    {
        case 1: finish1:
        case 2: finish2:
            match = input[0 .. r2];
            token = 0;
            break;
        case 3: finish3:
            match = input[0 .. r3];
            token = 0;
            break;
        default:
            return false;
    }
    return true;
}
// generated code end

#line 1551 "Compile2.d"
// Written in the D programming language

/*
 *  This file has been automatically generated by APaGeD v0.4.2 beta - Attributed Parser Generator for D.
 *
 *  Sections generated from custom input are marked as "generated code" and
 *  are subject to the terms and conditions stated in one of these sections.
 *  The remaining sections are part of the APaGeD package and subject
 *  to the terms and conditions of the corresponding license.
 *
 *  Attributed Parser Generator for D
 *  Copyright (c) 2007 Jascha Wetzel. All rights reserved
 *  License: Artistic License 2.0
 */


version(Tango)
{
    import tango.text.convert.Layout;
    import tango.text.Util;
    import tango.io.Stdout;

    private static Layout!(char) layout;

    static this()
    {
        layout = new Layout!(char);
    }

    string format(string fmt, ...)
    {
        return layout.convert(_arguments, _argptr, fmt);
    }

    alias char[] string;
}
else
{
    import std.string;
    import std.utf;
    debug import std.stdio;
}



/**************************************************************************************************
    Parser
**************************************************************************************************/

typedef uint Token;
alias Token Symbol;

const Token     EPSILON         = 1,
                ALTERN          = 2,
                EOS             = 3,
                FIRST_TOKEN     = 4,
                FIRST_NT        = 0x1000;

// generated code start
/*  Attributed Parser Generator for D
 *  Copyright (c) 2007 Jascha Wetzel. All rights reserved
 *  License: Artistic License 2.0, see license.txt
 */

const uint  MAX_INPUT_DUMP = 70,
            LR_STACK_RESERVE = 100,
            NODE_STACK_RESERVE = 20,
            BRANCH_STACK_RESERVE = 100;

/*******************************************************************************
    Stack based on dynamic array
*******************************************************************************/
struct Stack(T)
{
    size_t  _top;
    T[]     stack;

    void push(T v)
    {
        if ( _top >= stack.length )
            stack.length = stack.length*2+1;
        stack[_top] = v;
        ++_top;
    }

    void push(T[] vs)
    {
        size_t end = _top+vs.length;
        if ( end > stack.length )
            stack.length = end*2;
        stack[_top..end] = vs;
        _top = end;
    }
    alias push opCatAssign;

    void pop(size_t num)
    {
        assert(_top>=num);
        if ( num >= _top )
            _top = 0;
        else
            _top -= num;
    }

    T pop()
    {
        assert(_top>0);
        return stack[--_top];
    }

    T* popPtr()
    {
        assert(_top>0);
        return &stack[--_top];
    }

    T top()
    {
        assert(_top>0);
        return stack[_top-1];
    }

    T* topPtr()
    {
        assert(_top>0);
        return &stack[_top-1];
    }

    bool empty()
    {
        return _top == 0;
    }

    void clear()
    {
        _top = 0;
    }

    size_t length()
    {
        return _top;
    }

    T[] array()
    {
        return stack[0.._top];
    }

    Stack dup()
    {
        Stack s;
        s._top = _top;
        s.stack = stack.dup;
        return s;
    }
}

/**************************************************************************************************
    Information about rules needed for reduction and error handling
**************************************************************************************************/
align(1) struct RuleInfo
{
    bool    ast_node;
    uint    symbol_count,
            nt_count,
            nt_index;
    Symbol[]  symbols;
}

/**************************************************************************************************
    Information about LALR(1) entries needed for debugging
**************************************************************************************************/
align(1) struct EntryInfo
{
    uint    rule_index,
            pos;
}

/**************************************************************************************************
    Exception thrown on parser error
**************************************************************************************************/
class ParserException : Exception
{
    uint    line,
            column;
    string  filename,
            error_message,
            detail;

    this(uint line_, uint column_, string fname, string msg, string dtl="detail")
    {
        version(Tango)
            super(format("{}({}:{}): {}{}", fname, line_, column_, msg, dtl !is null?"\n"~dtl:""));
        else
            super(format("%s(%d:%d): %s%s", fname, line_, column_, msg, dtl !is null?"\n"~dtl:""));
        filename = fname;
        error_message = msg;
        line = line_;
        column = column_;
        detail = dtl;
    }
}

/**************************************************************************************************
    Wraps instantiation of the GLR parser class and the parse call.
**************************************************************************************************/
bool parse(string filename, string input, out SyntaxTree* root, bool detailed=false, bool recover=false, uint tab_width=4)
{
    GLRParser   g, w;
    static if ( is(typeof(WhitespaceGrammar) : GLRParser) )
        w = new WhitespaceGrammar;
    g = new MainGrammar(w, tab_width);
    bool succ = g.parse(filename, input, &root, detailed, recover);
    return succ;
}

/**************************************************************************************************
    GLR parser
**************************************************************************************************/
abstract class GLRParser
{
    struct LRState
    {
        uint    index,
                line,
                column;
    }
    
    struct Node
    {
        SyntaxTree* node;
        bool        sync;
    }

    struct LRBranch
    {
        Stack!(LRState) stack;
        Stack!(Node)    node_stack;
        string          input,
                        lookahead,
                        lookahead_ws;
        uint            line,
                        column,
                        symbol;
        bool            fatal_errors;
        uint            action;
        version(ProfileConflicts)
            uint            last_conflict;
    }
    
    string          filename;
    uint            tab_width;
    
    // operational variables
    string              match,
                        match_ws,
                        lookahead,
                        lookahead_ws;
    SyntaxTree*         syntax_root;
    SyntaxTree[]        syntax_tree_pool;
    size_t              pool_top;
    Stack!(LRState)     stack;
    Stack!(Node)        node_stack;
    Stack!(LRBranch)    branch_stack;
    ParserException[]   recovered_errors;
    bool                recover_from_errors,
                        detailed_errors;

    version(ProfileConflicts) {
        uint[uint]      rr_conflict_counts,
                        sr_conflict_counts,
                        shift_failed_counts,
                        reduce_failed_counts;
        uint            branch_stack_max;
    }

    // grammar data
    GLRParser       ws_parser;
    uint            first_nt;
    RuleInfo[]      rule_infos;
    string[][]      error_message_lists;
    string[]        nt_names,
                    lexeme_names;
    EntryInfo[][]   entry_infos;

    this(GLRParser ws, uint tabw)
    {
        ws_parser = ws;
        tab_width = tabw;
        stack.stack.length = LR_STACK_RESERVE;
        node_stack.stack.length = NODE_STACK_RESERVE;
        branch_stack.stack.length = BRANCH_STACK_RESERVE;
    }

    /**************************************************************************************************
        Gets overridden with a first-longest-match lexical analizer.
    **************************************************************************************************/
    bool function(string, out uint, out string) lexer;

    /**************************************************************************************************
        Gets overridden with the main parser function.
    **************************************************************************************************/
    bool parse(string input) { return false; }
    bool parseWS(ref string input) { return false; }

    /**************************************************************************************************

    **************************************************************************************************/
    bool isErrorSynced(uint state);

    /**************************************************************************************************

    **************************************************************************************************/
    T APDmin(T)(T a, T b) { return a<b?a:b; }
    uint[] lookaheadForNT(uint nt_index, uint state);

    /**************************************************************************************************
        Count lines and columns in str
    **************************************************************************************************/
    uint countLocation(string str, ref uint col)
    {
        uint count;
        dchar linefeed;
        foreach ( c; str )
        {
            if ( c == 10 || c == 13 )
            {
                if ( linefeed == dchar.init || linefeed == c ) {
                    ++count;
                    col = 1;
                    linefeed = c;
                }
                else
                    linefeed = dchar.init;
            }
            else if ( c == 9 ) {
                col += tab_width;
                linefeed = dchar.init;
            }
            else {
                ++col;
                linefeed = dchar.init;
            }
        }
        return count;
    }

    /**************************************************************************************************
        Initiates the parse call.
    **************************************************************************************************/
    final bool parse(string fname, string input, SyntaxTree** root=null, bool detailed=false, bool recover=false)
    {
        filename = fname;
        recover_from_errors = recover;
        detailed_errors = detailed;

        stack.clear;
        node_stack.clear;
        branch_stack.clear;
        pool_top = 0;
        syntax_tree_pool = null;
        recovered_errors = null;

        if ( input.length > 1 )
        {
            if ( input[0 .. 2] == "\xfe\xff" ) {
                // UTF-16BE
                input = input[2 .. $];
            }
            else if ( input[0 .. 2] == "\xff\xfe" )
            {
                if ( input.length > 3 && input[2 .. 4] == "\x00\x00" ) {
                    // UTF-32LE
                    input = input[4 .. $];
                }
                else {
                    // UTF-16LE
                    input = input[2 .. $];
                }
            }
            else if ( input.length > 2 && input[0 .. 3] == "\xef\xbb\xbf" ) {
                // UTF-8
                input = input[3 .. $];
            }
            else if ( input.length > 3 && input[0 .. 4] == "\x00\x00\xfe\xff" ) {
                // UTF-32BE
                input = input[4 .. $];
            }
            else if ( input[0] > 0x7f )
                return false;
        }
        
        stack ~= LRState(0, 1, 1);
        if ( parse(input) )
        {
            if ( syntax_root !is null && root !is null )
            {
                *root = syntax_root;
                debug
                {
                    Stack!(SyntaxTree*) st;
                    st.push(*root);
                    while ( !st.empty )
                    {
                        SyntaxTree* pn = st.pop;
                        foreach ( c; pn._ST_children ) {
                            c.parent = pn;
                            st.push(c);
                        }
                    }
                }
            }
            return true;
        }
        return false;
    }

    /**************************************************************************************************
        Create a node for the syntax tree. Used by the main parse function.
    **************************************************************************************************/
    debug void createNode(uint line, uint column, uint rule_index, uint nt_count, uint nt_index)
    {
        if ( pool_top >= syntax_tree_pool.length )
            syntax_tree_pool.length = syntax_tree_pool.length*2+1;
        auto pn = &syntax_tree_pool[pool_top];
        ++pool_top;
        pn._ST_rule = rule_index;
        pn._ST_line_number = line;
        pn._ST_column_number = column;
        pn._ST_node_name = nt_names[nt_index];

        if ( nt_count > 0 )
        {
            pn._ST_children.length = nt_count;
            foreach ( i, n; node_stack.array[$-nt_count .. $] )
                pn._ST_children[i] = n.node;
            node_stack.pop(nt_count);
        }
        else {
            pn._ST_match = match;
            pn._ST_match_ws = match_ws;
        }
        node_stack ~= Node(pn, false);
    }

    else void createNode(uint line, uint column, uint rule_index, uint nt_count)
    {
        if ( pool_top >= syntax_tree_pool.length )
            syntax_tree_pool.length = syntax_tree_pool.length*2+1;
        auto pn = &syntax_tree_pool[pool_top];
        ++pool_top;
        pn._ST_rule = rule_index;
        pn._ST_line_number = line;
        pn._ST_column_number = column;

        if ( nt_count > 0 )
        {
            pn._ST_children.length = nt_count;
            foreach ( i, n; node_stack.array[$-nt_count .. $] )
                pn._ST_children[i] = n.node;
            node_stack.pop(nt_count);
        }
        else {
            pn._ST_match = match;
            pn._ST_match_ws = match_ws;
        }
        node_stack ~= Node(pn, false);
    }

    /**************************************************************************************************

    **************************************************************************************************/
    string ruleToString(RuleInfo* ri, int pos)
    {
        version(Tango)
            string str = format("{} ->", nt_names[ri.nt_index]);
        else
            string str = format("%s ->", nt_names[ri.nt_index]);
        
        foreach ( i, s; ri.symbols )
        {
            string name;
            if ( s == ALTERN )
                name = "ALTERN";
            else if ( s < FIRST_NT )
                name = lexeme_names[s-EOS];
            else
                name = nt_names[s-FIRST_NT];
            if ( i == pos )
                str ~= " .";
            version(Tango)
                str ~= format(" {}", name);
            else
                str ~= format(" %s", name);
        }
        if ( pos == ri.symbols.length )
            str ~= " .";
        return str;
    }

    /**************************************************************************************************
        Issue an error. Used by the main parse function.
    **************************************************************************************************/
    void error(string input, uint line, uint column, uint error_list, uint symbol, bool fatal=true)
    {
        // collect explicit error messages
        string errors;
        foreach ( i, err; error_message_lists[error_list] )
        {
            if ( i > 0 )
                errors ~= "\n";
            errors ~= err;
        }

        // construct automatic error message
        // if no explicit error message available
        if ( errors.length == 0 )
        {
            bool[string] expected_symbols;
            EntryInfo[] eis = entry_infos[stack.top.index];
            foreach ( ei; eis )
            {
                RuleInfo* ri = &rule_infos[ei.rule_index];
                if ( ei.pos < ri.symbols.length )
                {
                    auto s = ri.symbols[ei.pos];
                    if ( s < FIRST_NT )
                        expected_symbols["\""~lexeme_names[s-EOS]~"\""] = true;
                    else
                        expected_symbols[nt_names[s-FIRST_NT]] = true;
                }
                else
                {
                    foreach ( token; lookaheadForNT(ri.nt_index, stack.top.index) ) {
                        assert(token < FIRST_NT);
                        expected_symbols["\""~lexeme_names[token-EOS]~"\""] = true;
                    }
                }
            }

            string expected_str;
            auto last = expected_symbols.length-1;
            foreach ( i, symname; expected_symbols.keys )
            {
                if ( i > 0 )
                {
                    if ( i == last )
                        expected_str ~= " or ";
                    else 
                        expected_str ~= ", ";
                }
                expected_str ~= symname;
            }
            version(Tango)
                errors = format("found \"{}\", expected {}", lookahead, expected_str);
            else
                errors = format("found \"%s\", expected %s", lookahead, expected_str);
        }

        // construct detail message
        string detail;
        if ( detailed_errors )
        {
            string          lr_stack;
            foreach ( st; stack.array[1..$] )
            {
                version(Tango)
                    lr_stack ~= format("---- State {}{} ({}:{}) ----\n", st.index, isErrorSynced(st.index)?"*":"", st.line, st.column);
                else
                    lr_stack ~= format("---- State %d%s (%d:%d) ----\n", st.index, isErrorSynced(st.index)?"*":"", st.line, st.column);
                EntryInfo[] eis = entry_infos[st.index];
                foreach ( ei; eis )
                    lr_stack ~= ruleToString(&rule_infos[ei.rule_index], ei.pos)~"\n";
            }
            
            string node_stack_str;
            foreach ( i, n; node_stack.array )
            {
                if ( i > 0 )
                    node_stack_str ~= " ";
                node_stack_str ~= nt_names[rule_infos[n.node._ST_rule].nt_index];
                if ( n.sync )
                    node_stack_str ~= "*";
            }

            version(Tango)
                detail = format("input: {}\nlookahead: {}\nlexeme: {}\nAST node stack:\n{}\nLR stack:\n{}",
                    substitute(substitute(input[0..$>MAX_INPUT_DUMP?MAX_INPUT_DUMP:$], "\r", "\\r"), "\n", "\\n"),
                    lookahead, lexeme_names[symbol-EOS],
                    node_stack_str, lr_stack
                );
            else
                detail = format("input: %s\nlookahead: %s\nlexeme: %s\nAST node stack:\n%s\nLR stack:\n%s",
                    replace(replace(input[0..$>MAX_INPUT_DUMP?MAX_INPUT_DUMP:$], "\r", "\\r"), "\n", "\\n"),
                    lookahead, lexeme_names[symbol-EOS],
                    node_stack_str, lr_stack
                );
        }

        // throw error
        if ( fatal ) {
            version(Tango) Stdout.flush;
            throw new ParserException(line, column-lookahead.length, filename, errors, detail);
        }
        else
        {
            version(Tango)
                debug(nonfatal) Stdout.flush.format("\n{}({}:{}): {}\n{}\n", filename, line, column-lookahead.length, errors, detail);
            else
                debug(nonfatal) writefln("\n%s(%d:%d): %s\n%s", filename, line, column-lookahead.length, errors, detail);
        }
    }
}

/**************************************************************************************************
    Generated parsers
**************************************************************************************************/
class MainGrammar : public GLRParser
{
    const ushort[]  action_base =
    [
        0,11,36,60,84,108,119,0,144,11,155,139,166,185,182,209,209,234,245,270,294,305,330,354,378,
        402,426,440,3,451,245,476,473,500,500,525,536,561,572,597,621,635,660,684,708,719,744,755,
        780,804,828,1,13,852,9,876,890,27,915,939,0
    ];
    const ubyte[]  action_check =
    [
        60,61,61,61,61,61,61,61,61,61,0,9,9,61,0,0,0,0,0,7,51,1,28,28,0,1,1,1,1,1,9,9,52,54,9,1,2,2,
        2,2,2,2,2,2,2,2,2,2,2,2,57,61,61,61,61,2,2,61,61,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,61,61,61,61,
        61,3,3,61,61,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,61,61,61,61,61,4,4,61,61,4,5,5,5,5,5,5,5,5,5,5,
        5,5,5,5,61,61,61,61,61,5,5,6,61,5,61,6,6,6,6,6,61,11,11,11,61,6,8,8,8,8,8,8,8,8,8,8,8,8,8,
        8,11,11,61,61,11,8,8,10,61,8,61,10,10,10,10,10,61,61,12,61,61,10,12,12,12,12,12,13,13,13,
        13,13,12,61,14,61,61,61,14,14,14,14,14,61,61,61,13,13,14,61,13,15,15,15,15,15,15,15,15,15,
        61,16,61,61,61,16,16,16,16,16,15,15,61,61,15,16,17,17,17,17,17,17,17,17,17,17,17,30,30,30,
        61,61,61,61,61,17,17,18,61,17,61,18,18,18,18,18,30,30,61,61,30,18,19,19,19,19,19,19,19,19,
        19,19,19,19,19,19,61,61,61,61,19,19,19,19,19,19,20,20,20,20,20,20,20,20,20,20,20,20,20,20,
        61,61,61,61,61,20,20,21,61,20,61,21,21,21,21,21,61,61,61,61,61,21,22,22,22,22,22,22,22,22,
        22,22,22,22,22,22,61,61,61,61,61,22,22,61,61,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
        61,61,61,61,61,23,23,61,61,23,24,24,24,24,24,24,24,24,24,24,24,24,24,24,61,61,61,61,61,24,
        24,61,61,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,61,61,61,61,61,25,25,61,61,25,26,26,
        26,26,26,26,26,26,26,26,26,26,26,26,61,61,61,61,26,26,26,26,26,26,27,61,61,61,27,27,27,27,
        27,27,61,29,61,61,27,29,29,29,29,29,29,61,61,61,61,29,31,31,31,31,31,61,61,32,61,61,61,32,
        32,32,32,32,61,61,61,31,31,32,61,31,33,33,33,33,33,33,33,33,33,61,34,61,61,61,34,34,34,34,
        34,33,33,61,61,33,34,35,35,35,35,35,35,35,35,35,35,35,61,61,61,61,61,61,61,61,35,35,36,61,
        35,61,36,36,36,36,36,61,61,61,61,61,36,37,37,37,37,37,37,37,37,37,37,37,37,37,37,61,61,61,
        61,61,37,37,38,61,37,61,38,38,38,38,38,61,61,61,61,61,38,39,39,39,39,39,39,39,39,39,39,39,
        39,39,39,61,61,61,61,61,39,39,61,61,39,40,40,40,40,40,40,40,40,40,40,40,40,40,40,61,61,61,
        61,40,40,40,40,40,40,41,61,61,61,41,41,41,41,41,61,61,61,61,61,41,42,42,42,42,42,42,42,42,
        42,42,42,42,42,42,61,61,61,61,61,42,42,61,61,42,43,43,43,43,43,43,43,43,43,43,43,43,43,43,
        61,61,61,61,61,43,43,61,61,43,44,44,44,44,44,44,44,44,44,44,44,44,44,44,61,61,61,61,61,44,
        44,45,61,44,61,45,45,45,45,45,61,61,61,61,61,45,46,46,46,46,46,46,46,46,46,46,46,61,61,61,
        61,61,61,61,61,46,46,47,61,46,61,47,47,47,47,47,61,61,61,61,61,47,48,48,48,48,48,48,48,48,
        48,48,48,61,61,61,61,61,61,61,61,48,48,61,61,48,49,49,49,49,49,49,49,49,49,49,49,61,61,61,
        61,61,61,61,61,49,49,61,61,49,50,50,50,50,50,50,50,50,50,61,61,61,61,61,61,61,61,61,61,50,
        50,61,61,50,53,53,53,53,53,53,53,53,53,53,53,53,53,53,61,61,61,61,61,53,53,61,61,53,55,55,
        55,55,55,55,55,55,55,55,55,55,55,55,61,61,61,61,55,55,55,55,55,55,56,61,61,61,56,56,56,56,
        56,61,61,61,61,61,56,58,58,58,58,58,58,58,58,58,58,58,58,58,58,61,61,61,61,58,58,58,58,58,
        58,59,59,59,59,59,59,59,59,59,59,59,59,59,59,61,61,61,61,61,59,59,61,61,59
    ];
    const ubyte[]  action_data =
    [
        0,192,192,192,192,192,192,192,192,192,65,128,74,192,66,67,68,69,70,72,159,65,160,93,83,66,
        67,68,69,70,128,128,117,83,128,83,150,150,150,150,150,150,150,150,150,150,150,150,150,150,
        122,192,192,192,192,150,150,192,192,150,151,151,151,151,151,151,151,151,151,151,151,151,
        151,151,192,192,192,192,192,151,151,192,192,151,152,152,152,152,152,152,152,152,152,152,
        152,152,152,152,192,192,192,192,192,152,152,192,192,152,153,153,153,153,153,153,153,153,
        153,153,153,153,153,153,192,192,192,192,192,153,153,65,192,153,192,66,67,68,69,70,192,130,
        130,76,192,83,157,157,157,157,157,157,157,157,157,157,157,157,157,157,130,130,192,192,130,
        157,157,65,192,157,192,66,67,68,69,70,192,192,65,192,192,83,66,67,68,69,70,132,132,132,78,
        96,83,192,65,192,192,192,66,67,68,69,70,192,192,192,132,132,83,192,132,134,134,134,134,134,
        80,98,109,111,192,65,192,192,192,66,67,68,69,70,134,134,192,192,134,83,137,137,137,137,137,
        137,137,137,137,82,100,129,129,76,192,192,192,192,192,137,137,65,192,137,192,66,67,68,69,
        70,129,129,192,192,129,83,165,165,165,165,165,165,165,165,165,165,165,165,165,165,192,192,
        192,192,165,165,165,165,165,165,141,141,141,141,141,141,141,141,141,141,141,85,102,105,192,
        192,192,192,192,141,141,65,192,141,192,66,67,68,69,70,192,192,192,192,192,83,144,144,144,
        144,144,144,144,144,144,144,144,144,144,144,192,192,192,192,192,144,144,192,192,144,154,
        154,154,154,154,154,154,154,154,154,154,154,154,154,192,192,192,192,192,154,154,192,192,
        154,149,149,149,149,149,149,149,149,149,149,149,149,149,149,192,192,192,192,192,149,149,
        192,192,149,155,155,155,155,155,155,155,155,155,155,155,155,155,155,192,192,192,192,192,
        155,155,192,192,155,156,156,156,156,156,156,156,156,156,156,156,156,156,156,192,192,192,
        192,91,156,156,118,120,156,65,192,192,192,66,67,68,69,70,161,192,65,192,192,83,66,67,68,69,
        70,161,192,192,192,192,83,131,131,131,78,96,192,192,65,192,192,192,66,67,68,69,70,192,192,
        192,131,131,83,192,131,135,135,135,135,135,80,98,109,111,192,65,192,192,192,66,67,68,69,70,
        135,135,192,192,135,83,138,138,138,138,138,138,138,138,138,82,100,192,192,192,192,192,192,
        192,192,138,138,65,192,138,192,66,67,68,69,70,192,192,192,192,192,83,142,142,142,142,142,
        142,142,142,142,142,142,85,102,105,192,192,192,192,192,142,142,65,192,142,192,66,67,68,69,
        70,192,192,192,192,192,83,145,145,145,145,145,145,145,145,145,145,145,145,145,145,192,192,
        192,192,192,145,145,192,192,145,164,164,164,164,164,164,164,164,164,164,164,164,164,164,
        192,192,192,192,164,164,164,164,164,164,65,192,192,192,66,67,68,69,70,192,192,192,192,192,
        83,146,146,146,146,146,146,146,146,146,146,146,146,146,146,192,192,192,192,192,146,146,192,
        192,146,147,147,147,147,147,147,147,147,147,147,147,147,147,147,192,192,192,192,192,147,
        147,192,192,147,143,143,143,143,143,143,143,143,143,143,143,85,102,105,192,192,192,192,192,
        143,143,65,192,143,192,66,67,68,69,70,192,192,192,192,192,83,139,139,139,139,139,139,139,
        139,139,82,100,192,192,192,192,192,192,192,192,139,139,65,192,139,192,66,67,68,69,70,192,
        192,192,192,192,83,140,140,140,140,140,140,140,140,140,82,100,192,192,192,192,192,192,192,
        192,140,140,192,192,140,136,136,136,136,136,136,136,136,136,82,100,192,192,192,192,192,192,
        192,192,136,136,192,192,136,133,133,133,133,133,80,98,109,111,192,192,192,192,192,192,192,
        192,192,192,133,133,192,192,133,158,158,158,158,158,158,158,158,158,158,158,158,158,158,
        192,192,192,192,192,158,158,192,192,158,162,162,162,162,162,162,162,162,162,162,162,162,
        162,162,192,192,192,192,162,162,162,162,162,162,65,192,192,192,66,67,68,69,70,192,192,192,
        192,192,83,163,163,163,163,163,163,163,163,163,163,163,163,163,163,192,192,192,192,163,163,
        163,163,163,163,148,148,148,148,148,148,148,148,148,148,148,148,148,148,192,192,192,192,
        192,148,148,192,192,148
    ];
    const ubyte[]  goto_base =
    [
        0,7,0,0,0,0,21,0,0,0,33,0,44,0,54,0,63,0,71,0,0,78,0,0,0,0,0,92,0,106,0,0,116,0,125,0,133,0,
        140,0,0,147,0,0,0,156,0,165,0,0,0,0,0,0,5,0,179,0,0,0,0
    ];
    const ubyte[]  goto_check =
    [
        0,0,0,0,0,0,0,0,0,0,0,61,0,0,1,1,1,1,54,1,1,6,6,6,6,6,6,6,6,6,6,6,61,6,6,10,10,10,10,10,10,
        10,10,10,61,10,10,12,12,12,12,12,12,12,12,61,12,12,14,14,14,14,14,14,14,61,14,14,16,16,16,
        16,16,16,61,16,16,18,18,18,18,18,61,18,18,21,21,21,21,61,21,21,27,27,27,27,27,27,27,27,27,
        27,27,27,27,27,29,29,29,29,29,29,29,29,29,29,29,29,29,29,32,32,32,32,32,32,32,61,32,32,34,
        34,34,34,34,34,61,34,34,36,36,36,36,36,61,36,36,38,38,38,38,61,38,38,41,41,41,41,61,41,41,
        45,45,45,45,45,45,61,45,45,47,47,47,47,47,47,61,47,47,56,56,56,56,56,56,56,56,56,56,56,61,
        56,56
    ];
    const ubyte[]  goto_data =
    [
        60,9,30,31,50,49,44,43,23,24,25,61,26,40,59,23,24,25,55,26,40,7,9,30,31,50,49,44,43,23,24,
        25,61,26,40,11,31,50,49,44,43,23,24,25,61,26,40,13,50,49,44,43,23,24,25,61,26,40,15,49,44,
        43,23,24,25,61,26,40,17,44,43,23,24,25,61,26,40,20,43,23,24,25,61,26,40,22,23,24,25,61,26,
        40,28,9,30,31,50,49,44,43,23,24,25,52,26,40,28,9,30,31,50,49,44,43,23,24,25,51,26,40,33,49,
        44,43,23,24,25,61,26,40,35,44,43,23,24,25,61,26,40,37,43,23,24,25,61,26,40,39,23,24,25,61,
        26,40,42,23,24,25,61,26,40,46,44,43,23,24,25,61,26,40,48,44,43,23,24,25,61,26,40,57,9,30,
        31,50,49,44,43,23,24,25,61,26,40
    ];

    debug(parser) string indent;
    
    this(GLRParser ws=null, uint tab_width=4)
    {
        super(ws, tab_width);
        lexer = &mainLexer;
        first_nt = 28;
        nt_names =
        [
            "Expr","OrExpr","AndExpr","EqualityExpr","RelationalExpr","AdditiveExpr","MulExpr",
            "UnaryExpr","Literal","PrimaryExpr","FuncCall","ExprList","VarRef","Identifier",
            "!LRstart"
        ];
        lexeme_names =
        [
            "EOS","\\|\\|","&&","==","!=","\\<","\\>","\\<=","\\>=","\\+","\\-","\\*","div","mod",
            "\"[^\"]*\"","'[^']*'","[0-9]+","[0-9]+\\.[0-9]+","\\(","\\)",",","\\.","\\[","\\]",
            "[A-Za-z_][A-Za-z_0-9]*"
        ];
        entry_infos =
        [
            cast(EntryInfo[])[],[EntryInfo(20,1)],[EntryInfo(22,1)],[EntryInfo(23,1)],[EntryInfo(24,1)],[
            EntryInfo(25,1)],[EntryInfo(29,1)],[EntryInfo(29,2)],[EntryInfo(29,3)],[EntryInfo(0,1),EntryInfo(2,1)],[
            EntryInfo(2,2)],[EntryInfo(2,3),EntryInfo(4,1)],[EntryInfo(4,2)],[EntryInfo(4,3),EntryInfo(6,1)
            ,EntryInfo(7,1)],[EntryInfo(6,2)],[EntryInfo(6,3),EntryInfo(9,1),EntryInfo(10,1),EntryInfo(11,1)
            ,EntryInfo(12,1)],[EntryInfo(9,2)],[EntryInfo(9,3),EntryInfo(13,1),EntryInfo(14,1)],[EntryInfo(13,2)],[
            EntryInfo(37,1)],[EntryInfo(13,3),EntryInfo(16,1),EntryInfo(17,1),EntryInfo(18,1)],[EntryInfo(16,2)],[
            EntryInfo(16,3)],[EntryInfo(26,1)],[EntryInfo(21,1)],[EntryInfo(27,1)],[EntryInfo(28,1),EntryInfo(30,1)
            ,EntryInfo(34,1),EntryInfo(35,1)],[EntryInfo(30,2),EntryInfo(33,0)],[EntryInfo(31,1),EntryInfo(32,1)],[
            EntryInfo(31,2),EntryInfo(33,0)],[EntryInfo(1,1),EntryInfo(4,1)],[EntryInfo(3,1),EntryInfo(6,1)
            ,EntryInfo(7,1)],[EntryInfo(7,2)],[EntryInfo(7,3),EntryInfo(9,1),EntryInfo(10,1),EntryInfo(11,1)
            ,EntryInfo(12,1)],[EntryInfo(10,2)],[EntryInfo(10,3),EntryInfo(13,1),EntryInfo(14,1)],[EntryInfo(14,2)],[
            EntryInfo(14,3),EntryInfo(16,1),EntryInfo(17,1),EntryInfo(18,1)],[EntryInfo(17,2)],[EntryInfo(17,3)],[
            EntryInfo(36,1)],[EntryInfo(18,2)],[EntryInfo(18,3)],[EntryInfo(19,1)],[EntryInfo(15,1),EntryInfo(16,1)
            ,EntryInfo(17,1),EntryInfo(18,1)],[EntryInfo(11,2)],[EntryInfo(11,3),EntryInfo(13,1),EntryInfo(14,1)],[
            EntryInfo(12,2)],[EntryInfo(12,3),EntryInfo(13,1),EntryInfo(14,1)],[EntryInfo(8,1),EntryInfo(13,1)
            ,EntryInfo(14,1)],[EntryInfo(5,1),EntryInfo(9,1),EntryInfo(10,1),EntryInfo(11,1),EntryInfo(12,1)],[
            EntryInfo(31,3)],[EntryInfo(30,3)],[EntryInfo(30,4)],[EntryInfo(34,2)],[EntryInfo(34,3)],[
            EntryInfo(35,2)],[EntryInfo(35,3)],[EntryInfo(35,4)],[EntryInfo(20,2)],[EntryInfo(38,1)]
        ];
        rule_infos =
        [
            RuleInfo(true,1,1,0,[4097]),RuleInfo(true,1,1,1,[4098]),
            RuleInfo(true,3,2,1,[4097,4,4098]),RuleInfo(true,1,1,2,[4099]),RuleInfo(true,3,2,2,[4098,5,4099]),
            RuleInfo(true,1,1,3,[4100]),RuleInfo(true,3,2,3,[4099,6,4100]),RuleInfo(true,3,2,3,[4099,7,4100]),
            RuleInfo(true,1,1,4,[4101]),RuleInfo(true,3,2,4,[4100,8,4101]),RuleInfo(true,3,2,4,[4100,9,4101]),
            RuleInfo(true,3,2,4,[4100,10,4101]),RuleInfo(true,3,2,4,[4100,11,4101]),
            RuleInfo(true,3,2,5,[4101,12,4102]),RuleInfo(true,3,2,5,[4101,13,4102]),RuleInfo(true,1,1,5,[4102]),
            RuleInfo(true,3,2,6,[4102,14,4103]),RuleInfo(true,3,2,6,[4102,15,4103]),
            RuleInfo(true,3,2,6,[4102,16,4103]),RuleInfo(true,1,1,6,[4103]),RuleInfo(true,2,1,7,[13,4103]),
            RuleInfo(true,1,1,7,[4105]),RuleInfo(true,1,0,8,[17]),RuleInfo(true,1,0,8,[18]),
            RuleInfo(true,1,0,9,[19]),RuleInfo(true,1,0,9,[20]),RuleInfo(true,1,1,9,[4104]),
            RuleInfo(true,1,1,9,[4106]),RuleInfo(true,1,1,9,[4108]),RuleInfo(true,3,1,9,[21,4096,22]),
            RuleInfo(true,4,2,10,[4108,21,4107,22]),RuleInfo(true,3,2,11,[4096,23,4107]),
            RuleInfo(true,1,1,11,[4096]),RuleInfo(true,0,0,11,[]),RuleInfo(true,3,2,12,[4108,24,4109]),
            RuleInfo(true,4,2,12,[4108,25,4096,26]),RuleInfo(true,1,1,12,[4109]),RuleInfo(true,1,0,13,[27]),
            RuleInfo(true,1,1,14,[4096])
        ];
        error_message_lists = [
            cast(string[])null
        ];
    }

    uint[] lookaheadForNT(uint nt_index, uint state)
    {
        uint[] tokens;
        auto b = action_base[state];
        auto m = APDmin(action_check.length, cast(size_t)b+first_nt);
        foreach ( i, check; action_check[b .. m] )
        {
            if ( check == state && (action_data[b+i] & 192) == 128 )
                tokens ~= i+EOS;
        }
        return tokens;
    }

    override bool isErrorSynced(uint state)
    {
        switch ( state )
        {
            case 0:
                return true;
            default:
                break;
        }
        return false;
    }

    override bool parse(string input)
    {
        debug(parser) indent ~= " ";
        scope(exit) debug(parser) indent = indent[0..$-1];

        bool    fatal_errors = true;
        uint    line = 1,
                column = 1,
                symbol;

        void reduce(uint rule)
        {
            version(Tango)
                debug(parser) Stdout.format("{}reduce {} {}\n", indent, rule, ruleToString(&rule_infos[rule], -1));
            else
                debug(parser) writefln("%sreduce %d %s", indent, rule, ruleToString(&rule_infos[rule], -1));
            auto ri = &rule_infos[rule];
            uint    reduce_line,
                    reduce_column;
            if ( ri.symbol_count > 0 ) {
                reduce_line = stack.array[$-ri.symbol_count].line;
                reduce_column = stack.array[$-ri.symbol_count].column;
                stack.pop(ri.symbol_count);
            }
            else {
                reduce_line = stack.top.line;
                reduce_column = stack.top.column;
            }

            auto b = goto_base[stack.top.index];
            b += ri.nt_index;
            debug(parser)
            {
                if ( b < goto_check.length && goto_check[b] == stack.top.index ) {
                    stack ~= LRState(goto_data[b], reduce_line, reduce_column);

                version(Tango)
                    Stdout.format("{}goto {}\n", indent, stack.top.index);
                else
                    writefln("%sgoto %d", indent, stack.top.index);
                }
                else
                    assert(0);
            }
            else
                stack ~= LRState(goto_data[b], reduce_line, reduce_column);
            if ( ri.ast_node ) {
                debug createNode(reduce_line, reduce_column, rule, ri.nt_count, ri.nt_index);
                else createNode(reduce_line, reduce_column, rule, ri.nt_count);
            }
            else if ( ri.nt_count > 0 )
                node_stack.pop(ri.nt_count);
        }

        void branch(uint action)
        {
            version(ProfileConflicts)
            {
                if ( branch_stack.length > branch_stack_max )
                    branch_stack_max = branch_stack.length;
            }
            if ( (action & 64) > 0 )
            {
                version(ProfileConflicts)
                    sr_conflict_counts[stack.top.index]++;
                version(Tango) debug(parser) Stdout.format("{}branch shift conflict\n", indent);
                else debug(parser) writefln("%sbranch shift conflict", indent);
            }
            else
            {
                version(ProfileConflicts)
                    rr_conflict_counts[stack.top.index]++;
                version(Tango) debug(parser) Stdout.format("{}branch reduce conflict\n", indent);
                else debug(parser) writefln("%sbranch reduce conflict", indent);
            }
            version(ProfileConflicts)
                branch_stack ~= LRBranch(
                    stack.dup, node_stack.dup,
                    input, lookahead, lookahead_ws,
                    line, column, symbol, fatal_errors, 
                    action, stack.top.index | (action & 192)
                );
            else
                branch_stack ~= LRBranch(
                    stack.dup, node_stack.dup,
                    input, lookahead, lookahead_ws,
                    line, column, symbol, fatal_errors, 
                    action
                );
            fatal_errors = false;
        }

        string prev_input = input;
        parseLoop: while ( true )
        {
            if ( symbol == 0 )
            {
            readSymbol:
                match = lookahead;
                match_ws = lookahead_ws;
                lookahead_ws = input;
                static if ( is(typeof(WhitespaceGrammar) : GLRParser) )
                    ws_parser.parseWS(input);
                version(Tango)
                    debug(lexer) Stdout.format("WS: '{}'\n", lookahead_ws[0 .. $-input.length]);
                else
                    debug(lexer) writefln("WS: '%s'", lookahead_ws[0 .. $-input.length]);
                symbol = EOS;
                if ( input.length == 0 )
                    lookahead = null;
                else if ( lexer(input, symbol, lookahead) ) {
                    symbol += FIRST_TOKEN;
                    line += countLocation(lookahead_ws[0 .. $-input.length], column);
                    lookahead_ws = lookahead_ws[0 .. $-input.length+lookahead.length];
                }
                if ( symbol == 0 )
                    throw new ParserException(line, column, filename, "Invalid token", input[0..$>MAX_INPUT_DUMP?MAX_INPUT_DUMP:$]);
                prev_input = input;
                input = input[lookahead.length..$];
            }
            debug(parser)
            {
                string node_stack_str;
                foreach ( n; node_stack.array )
                    node_stack_str ~= " "~n.node._ST_node_name~(n.sync?"*":"");
                version(Tango)
                    Stdout.format("\n{}state {}\n{}nodes {}\n{}lkahd ({}) {}\n{}input ({}:{}) {}\n",
                        indent, stack.top.index,
                        indent, node_stack_str,
                        indent, symbol, lookahead,
                        indent, line, column,
                        substitute(substitute(input[0..$>MAX_INPUT_DUMP?MAX_INPUT_DUMP:$], "\r", "\\r"), "\n", "\\n")
                    );
                else
                    writefln("\n%sstate %d\n%snodes %s\n%slkahd (%d) %s\n%sinput (%d:%d) %s",
                        indent, stack.top.index,
                        indent, node_stack_str,
                        indent, symbol, lookahead,
                        indent, line, column,
                        replace(replace(input[0..$>MAX_INPUT_DUMP?MAX_INPUT_DUMP:$], "\r", "\\r"), "\n", "\\n")
                    );
            }

            auto state = stack.top.index;
            auto b = action_base[state];
            uint action = 192;
            b += symbol-EOS;
            if ( b < action_check.length && action_check[b] == state )
                action = action_data[b];

            actionSwitch: switch ( action & 192 )
            {
                case 64:
                    action &= 63;
                    version(Tango) debug(parser) Stdout.format("{}shift {}\n", indent, action);
                    else debug(parser) writefln("%sshift %d", indent, action);
                    stack ~= LRState(action, line, column);
                    symbol = 0;
                    continue parseLoop;
                case 128:
                    action &= 63;
                    version(Tango) debug(parser) Stdout.format("{}reduce {} {}\n", indent, action, ruleToString(&rule_infos[action], -1));
                    else debug(parser) writefln("%sreduce %d %s", indent, action, ruleToString(&rule_infos[action], -1));
                    auto ri = &rule_infos[action];
                    uint    reduce_line,
                            reduce_column;
                    if ( ri.symbol_count > 0 ) {
                        reduce_line = stack.array[$-ri.symbol_count].line;
                        reduce_column = stack.array[$-ri.symbol_count].column;
                        stack.pop(ri.symbol_count);
                    }
                    else {
                        reduce_line = stack.array[$-1].line;
                        reduce_column = stack.array[$-1].column;
                    }

                    state = stack.top.index;
                    b = goto_base[state];
                    b += ri.nt_index;
                    debug(parser)
                    {
                        if ( b < goto_check.length && goto_check[b] == state ) {
                            stack ~= LRState(goto_data[b], reduce_line, reduce_column);
                        version(Tango)
                            Stdout.format("{}goto {}\n", indent, stack.top.index);
                        else
                            writefln("%sgoto %d", indent, stack.top.index);
                        }
                        else
                            assert(0);
                    }
                    else
                        stack ~= LRState(goto_data[b], reduce_line, reduce_column);
                    if ( ri.ast_node ) {
                        debug createNode(reduce_line, reduce_column, action, ri.nt_count, ri.nt_index);
                        else createNode(reduce_line, reduce_column, action, ri.nt_count);
                    }
                    else if ( ri.nt_count > 0 )
                        node_stack.pop(ri.nt_count);

                    continue parseLoop;
                case 192:
                    action &= 63;
                    if ( fatal_errors || action > 0 )
                    {
                        if ( recover_from_errors )
                        {
                            try error(prev_input, line, column, action, symbol);
                            catch ( ParserException e )
                                recovered_errors ~= e;
                            version(Tango)
                                debug(nonfatal) Stdout.format("recovering from error:\n{}\n", recovered_errors[$-1]);
                            else
                                debug(nonfatal) writefln("recovering from error:\n%s", recovered_errors[$-1]);
                            while ( !stack.empty && !isErrorSynced(stack.top.index) )
                                stack.pop;
                            while ( !node_stack.empty && !node_stack.top.sync )
                                node_stack.pop;
                            symbol = 0;
                            continue parseLoop;
                        }
                        else {
                            input = prev_input;
                            error(input, line, column, action, symbol);
                        }
                    }
                    else
                    {
                        debug(nonfatal) {
                            input = prev_input;
                            error(input, line, column, action, symbol, false);
                        }
                    }
                    if ( branch_stack.length == 0 ) {
                        input = prev_input;
                        return false;
                    }
                    auto prev = branch_stack.popPtr;
                    stack           = prev.stack;
                    node_stack      = prev.node_stack;
                    input           = prev.input;
                    prev_input      = input;
                    lookahead       = prev.lookahead;
                    lookahead_ws    = prev.lookahead_ws;
                    line            = prev.line;
                    column          = prev.column;
                    symbol          = prev.symbol;
                    fatal_errors    = prev.fatal_errors;
                    action          = prev.action;

                    version(ProfileConflicts)
                    {
                        if ( (prev.last_conflict & 64) > 0 )
                            shift_failed_counts[prev.last_conflict & 63]++;
                        else
                            reduce_failed_counts[prev.last_conflict & 63]++;
                    }
                    goto actionSwitch;
                default:
                    break;
            }

            switch ( action )
            {
                case 0:
                    version(Tango)
                        debug(parser) Stdout.format("{}accept\n", indent);
                    else
                        debug(parser) writefln("%saccept", indent);
                    syntax_root = node_stack.top.node;
                    input = prev_input;
                    return true;
                default:
                    assert(0);
            }
        }
        assert(0);
    }
}

class WhitespaceGrammar : public GLRParser
{
    const ubyte[]  action_base =
    [
        0,0,2
    ];
    const ubyte[]  action_check =
    [
        1,0,2
    ];
    const ubyte[]  action_data =
    [
        4,3,0
    ];
    const ubyte[]  goto_base =
    [
        0,0,0
    ];
    const ubyte[]  goto_check =
    [
        0
    ];
    const ubyte[]  goto_data =
    [
        2
    ];

    debug(parser) string indent;
    
    this(GLRParser ws=null, uint tab_width=4)
    {
        super(ws, tab_width);
        lexer = &wsLexer;
        first_nt = 5;
        nt_names =
        [
            "Whitespace","!LRstart"
        ];
        lexeme_names =
        [
            "EOS","[ \\t\\n\\r]+"
        ];
        entry_infos =
        [
            cast(EntryInfo[])[],[EntryInfo(0,1)],[EntryInfo(1,1)]
        ];
        rule_infos =
        [
            RuleInfo(true,1,0,0,[4]),RuleInfo(true,1,1,1,[4096])
        ];
        error_message_lists = [
            cast(string[])null
        ];
    }

    uint[] lookaheadForNT(uint nt_index, uint state)
    {
        uint[] tokens;
        auto b = action_base[state];
        auto m = APDmin(action_check.length, cast(size_t)b+first_nt);
        foreach ( i, check; action_check[b .. m] )
        {
            if ( check == state && (action_data[b+i] & 6) == 4 )
                tokens ~= i+EOS;
        }
        return tokens;
    }

    override bool isErrorSynced(uint state)
    {
        switch ( state )
        {
            case 0:
                return true;
            default:
                break;
        }
        return false;
    }

    override bool parseWS(ref string input)
    {
        stack.clear;
        stack ~= LRState(0, 1, 1);

        debug(parser) indent ~= " ";
        scope(exit) debug(parser) indent = indent[0..$-1];

        bool    fatal_errors = true;
        uint    line = 1,
                column = 1,
                symbol;

        void reduce(uint rule)
        {
            version(Tango)
                debug(parser) Stdout.format("{}reduce {} {}\n", indent, rule, ruleToString(&rule_infos[rule], -1));
            else
                debug(parser) writefln("%sreduce %d %s", indent, rule, ruleToString(&rule_infos[rule], -1));
            auto ri = &rule_infos[rule];
            uint    reduce_line,
                    reduce_column;
            if ( ri.symbol_count > 0 ) {
                reduce_line = stack.array[$-ri.symbol_count].line;
                reduce_column = stack.array[$-ri.symbol_count].column;
                stack.pop(ri.symbol_count);
            }
            else {
                reduce_line = stack.top.line;
                reduce_column = stack.top.column;
            }

            auto b = goto_base[stack.top.index];
            b += ri.nt_index;
            debug(parser)
            {
                if ( b < goto_check.length && goto_check[b] == stack.top.index ) {
                    stack ~= LRState(goto_data[b], reduce_line, reduce_column);
                }
                else
                    assert(0);
            }
            else
                stack ~= LRState(goto_data[b], reduce_line, reduce_column);
        }

        void branch(uint action)
        {
            version(ProfileConflicts)
            {
                if ( branch_stack.length > branch_stack_max )
                    branch_stack_max = branch_stack.length;
            }
            if ( (action & 2) > 0 )
            {
                version(ProfileConflicts)
                    sr_conflict_counts[stack.top.index]++;
            }
            else
            {
                version(ProfileConflicts)
                    rr_conflict_counts[stack.top.index]++;
            }
            version(ProfileConflicts)
                branch_stack ~= LRBranch(
                    stack.dup, node_stack.dup,
                    input, lookahead, lookahead_ws,
                    line, column, symbol, fatal_errors, 
                    action, stack.top.index | (action & 6)
                );
            else
                branch_stack ~= LRBranch(
                    stack.dup, node_stack.dup,
                    input, lookahead, lookahead_ws,
                    line, column, symbol, fatal_errors, 
                    action
                );
            fatal_errors = false;
        }

        string prev_input = input;
        parseLoop: while ( true )
        {
            if ( symbol == 0 )
            {
            readSymbol:
                match = lookahead;
                match_ws = lookahead_ws;
                symbol = EOS;
                if ( input.length == 0 )
                    lookahead = null;
                else if ( lexer(input, symbol, lookahead) ) {
                    symbol += FIRST_TOKEN;
                }
                if ( symbol == 0 )
                    return false;
                prev_input = input;
                input = input[lookahead.length..$];
            }

            auto state = stack.top.index;
            auto b = action_base[state];
            uint action = 6;
            b += symbol-EOS;
            if ( b < action_check.length && action_check[b] == state )
                action = action_data[b];

            actionSwitch: switch ( action & 6 )
            {
                case 2:
                    action &= 1;
                    stack ~= LRState(action, line, column);
                    symbol = 0;
                    continue parseLoop;
                case 4:
                    action &= 1;
                    auto ri = &rule_infos[action];
                    uint    reduce_line,
                            reduce_column;
                    if ( ri.symbol_count > 0 ) {
                        reduce_line = stack.array[$-ri.symbol_count].line;
                        reduce_column = stack.array[$-ri.symbol_count].column;
                        stack.pop(ri.symbol_count);
                    }
                    else {
                        reduce_line = stack.array[$-1].line;
                        reduce_column = stack.array[$-1].column;
                    }

                    state = stack.top.index;
                    b = goto_base[state];
                    b += ri.nt_index;
                    debug(parser)
                    {
                        if ( b < goto_check.length && goto_check[b] == state ) {
                            stack ~= LRState(goto_data[b], reduce_line, reduce_column);
                        }
                        else
                            assert(0);
                    }
                    else
                        stack ~= LRState(goto_data[b], reduce_line, reduce_column);

                    continue parseLoop;
                case 6:
                    action &= 1;
                    input = prev_input;
                    if ( branch_stack.length == 0 ) {
                        input = prev_input;
                        return false;
                    }
                    auto prev = branch_stack.popPtr;
                    stack           = prev.stack;
                    node_stack      = prev.node_stack;
                    input           = prev.input;
                    prev_input      = input;
                    lookahead       = prev.lookahead;
                    lookahead_ws    = prev.lookahead_ws;
                    line            = prev.line;
                    column          = prev.column;
                    symbol          = prev.symbol;
                    fatal_errors    = prev.fatal_errors;
                    action          = prev.action;

                    version(ProfileConflicts)
                    {
                        if ( (prev.last_conflict & 2) > 0 )
                            shift_failed_counts[prev.last_conflict & 1]++;
                        else
                            reduce_failed_counts[prev.last_conflict & 1]++;
                    }
                    goto actionSwitch;
                default:
                    break;
            }

            switch ( action )
            {
                case 0:
                    input = prev_input;
                    return true;
                default:
                    assert(0);
            }
        }
        assert(0);
    }
}


// generated code end
